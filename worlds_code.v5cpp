{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n/*\ntodo list\n1. gyrocorrected move forward\n2. \n3. \n*/\n \n\n// Include Libarys\n#include \"vex.h\"\n#include \"algorithm\"\n#include \"utility\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\ncompetition Competition = competition();                                 \n\n\n// keyword Declreation \n#define Spin 0\n#define Stop 1\n#define SetSpeed 2\n#define SpinFor 3\n#define SetBraking 4\n#define SetTimeout 5\n#define SpinTo 6\n\n#define Brake 0\n#define Coast 1\n#define Hold 2\n\n#define Left 0\n#define Right 1\n#define Both 2\n\n#define Match 0\n#define Skills 1\n\n// Function and variable teasers\n  float map(float lowerA, float upperA, float lowerB, float upperB, float input);\n  float degreesConverter(float old);\n\n  void driveMacro(int action, float argument1 = 100000, float argument2 = 100000);\n  void driver_Control();\n  void printControllerStats();\n  void autonHelper();\n  void turnToDegree(int destination, int pivotSetting = Both, float timeout = 100000);\n  void moveForTurns(float destination, int timeout = 100000);\n  void cavemanMove(int speedLeft, int speedRight, int mode, int argument1, int argument2);\n\n  void auton_Matchload_AWP();\n  void auton_goalSide();\n  void auton_skills();\n  void auton_init();\n  void auton_matchloadTriballs(int triballs, int timeout = 10000);\n\n// Ports decleration\n  // drivetrain\n  controller Controller1 = controller(primary);\n  motor drive_leftFront = motor(PORT14, ratio18_1, true);\n  motor drive_leftMid = motor(PORT15, ratio18_1, false);\n  motor drive_leftBack = motor(PORT16, ratio18_1, true);\n  motor drive_rightFront = motor(PORT11, ratio18_1, false);\n  motor drive_rightMid = motor(PORT12, ratio18_1, true);\n  motor drive_rightBack = motor(PORT13, ratio18_1, false);\n  inertial drive_gyro = inertial(PORT19);\n\n  // intake and cata\n  motor outtake_motor = motor(PORT18, ratio6_1, true);\n  rotation cata_rotation = rotation(PORT3, true);\n  motor intake_motor = motor(PORT17, ratio36_1, true);\n\n  //pnematics\n  digital_out hang = digital_out(Brain.ThreeWirePort.G);\n  digital_out wings = digital_out(Brain.ThreeWirePort.H);\n  digital_out lowhang = digital_out(Brain.ThreeWirePort.F);\n\n  //variables\n  int mode = Match; // TODO\n\n  float turnP = 0.57;\n  float turnConst = 2;\n  float turnD = 0;\n  float moveP = 80;\n  float moveConst = 17;\n  // old values --> 0.35, 3, 0, 35, 15\n  \nvoid pre_auton(void){\n    auton_init();\n}\n\nint main() {\n  //auton_goalSide();\n  Competition.drivercontrol(driver_Control);\n  //For goal side:\n  Competition.autonomous(auton_goalSide);\n\n  // For AWP\n  //Competition.autonomous(auton_Matchload_AWP);\n\n  //For Auton Skills:\n  //Competition.autonomous(auton_skills);\n\n  //For Auton Helper:\n  //autonHelper();\n\n}\n\n\n\n\n\n\n\n// fuunctions\nvoid driver_Control() {\n  driveMacro(SetBraking, Coast);\n  int fwd, sideways, leftTrain, rightTrain;\n\n  outtake_state = Flywheel;\n  bool outtake_stateButtonPressed = false;\n  outtake_motor.setStopping(coast);\n\n  bool wingsState, wingsButtonPressed, hangState, hangButtonPressed, lowhangState, lowhangButtonPressed;\n  wingsState = hangState = false;\n\n  int timeLast = Brain.Timer.time(seconds);\n  int matchLength = 105;\n  if (mode == Skills) {\n    matchLength = 60;\n  }\n  int last_rumble = matchLength;\n\n  //printControllerStats();\n  while (true) {\n    // drivetrain\n    fwd = Controller1.Axis3.position();\n    sideways = Controller1.Axis1.position();\n    leftTrain = fwd + sideways;\n    rightTrain = fwd - sideways;\n    driveMacro(SetSpeed, leftTrain, rightTrain);\n    driveMacro(Spin);\n\n    // intake\n    if (Controller1.ButtonL1.pressing()) {\n      intake_motor.setVelocity(100, percent);\n      intake_motor.spin(forward);\n    }\n    else if (Controller1.ButtonL2.pressing()) {\n      intake_motor.setVelocity(-100, percent);\n      intake_motor.spin(forward);\n    }\n    else {\n      intake_motor.stop();\n    }\n\n    //outtake selection\n    if (Controller1.ButtonDown.pressing()) {\n      if (outtake_stateButtonPressed == false) {\n        if (outtake_state == Kicker) {\n          outtake_state = Flywheel;\n          printControllerStats();\n        } else {\n          outtake_state = Kicker;\n          printControllerStats();\n        }\n        outtake_stateButtonPressed = true;\n      }\n    } else if (outtake_stateButtonPressed){\n      outtake_stateButtonPressed = false;\n    }\n\n    //outtake \n    if (Controller1.ButtonX.pressing()) {\n      outtake_motor.setVelocity(100*outtake_state, percent);\n      outtake_motor.spin(forward);\n    } \n    else if (Controller1.ButtonY.pressing()) {\n      outtake_motor.setVelocity(cataSpeed*outtake_state, percent);\n      outtake_motor.spin(forward);\n    }\n    else if (Controller1.ButtonB.pressing()) {\n      outtake_motor.setVelocity(0, percent);\n      outtake_motor.stop();\n    }\n\n    //update controller stats if temp changed\n    /*\n      if (abs(lastOuttakeTemp - outtake_motor.temperature(percent)) > 5) {\n      lastOuttakeTemp = outtake_motor.temperature(percent);\n      printControllerStats();\n    }\n    */\n\n\n    // wings\n    if (Controller1.ButtonR2.pressing()) {\n      if (wingsButtonPressed == false) {\n        if (wingsState) {\n          wings.set(false);\n          wingsState = false;\n        } else {\n          wings.set(true);\n          wingsState = true;\n        }\n        wingsButtonPressed = true;\n      }\n    } else if (wingsButtonPressed) {\n      wingsButtonPressed = false;\n    }\n    //printf(\"%i\\n\",wingsButtonPressed);\n    //wait(0.5,seconds);\n\n    //hang\n    if (Controller1.ButtonA.pressing()) {\n      if (hangButtonPressed == false){\n        if (hangState) {\n          hang.set(false);\n          hangState = false;\n        } else {\n          hang.set(true);\n          hangState = true;\n        }\n      }\n      hangButtonPressed = true;\n    }\n    else {\n      hangButtonPressed = false;\n    }\n\n    //low hand\n    if (Controller1.ButtonR1.pressing()) {\n      if (lowhangButtonPressed == false){\n        if (lowhangState) {\n          lowhang.set(false);\n          lowhangState = false;\n        } else {\n          lowhang.set(true);\n          lowhangState = true;\n        }\n      }\n      lowhangButtonPressed = true;\n    }\n    else {\n      lowhangButtonPressed = false;\n    }\n\n\n\n    \n\n    //rumble for timer\n    if (Brain.Timer.time(seconds) - timeLast > matchLength - 30 && last_rumble > 30) {\n      Controller1.rumble(\"-\");\n      last_rumble = 30;\n    } else if (Brain.Timer.time(seconds) - timeLast > matchLength - 15 && last_rumble > 16) {\n      Controller1.rumble(\"--\");\n      last_rumble = 15;\n    } else if (Brain.Timer.time(seconds) - timeLast > matchLength - 10 && last_rumble > 11) {\n      Controller1.rumble(\"---\");\n      last_rumble = 10;\n    }\n\n    \n\n    /*// cata manual\n    if (Controller1.ButtonR1.pressing()) {\n        outtake_motor.setVelocity(cataSpeed, percent);\n        outtake_motor.spin(forward);\n    }\n    else if(cata_rotation.angle() < manualTurnBackAngle){\n      outtake_motor.spin(forward);\n    }\n    else if (cata_rotation.velocity(rpm) > 20){\n      outtake_motor.setVelocity(0, percent);\n      outtake_motor.stop();\n    }*/\n\n    wait(0.005, seconds);\n  }\n}\n\nvoid printControllerStats() {\n  Controller1.Screen.clearLine(3);\n  if (outtake_state == Flywheel) {\n    Controller1.Screen.print(\"Flywheel, \");\n  } \n  else {\n    Controller1.Screen.print(\"Kicker, \");\n  }\n  Controller1.Screen.print(outtake_motor.temperature(percent));\n}\n\n\n//helping functions\nfloat degreesConverter(float old) {\n  //measure rotations for back of bot meeting tile bottom line to next tile bottom line\n  float OLD_TILE_ROTATIONS = 0;\n  float NEW_TILE_ROTATIONS = 1.3;\n  return NEW_TILE_ROTATIONS / OLD_TILE_ROTATIONS * old;\n}\n\nvoid autonHelper() {\n  driveMacro(SetBraking, Coast);\n  float pastLeft = 0;\n  float pastRight = 0;\n  while (1) {\n    Brain.Screen.print(\"left: \");\n    Brain.Screen.print(drive_leftFront.position(turns) - pastLeft);\n    Brain.Screen.print(\" right: \");\n    Brain.Screen.print(drive_rightFront.position(turns) - pastRight);\n    Brain.Screen.print(\" gyro: \");\n    Brain.Screen.print(drive_gyro.heading(degrees));\n    Brain.Screen.newLine();\n\n    if (Controller1.ButtonRight.pressing()) {\n      Controller1.Screen.print(\"gyro: \");\n      Controller1.Screen.print(drive_gyro.heading(degrees));\n      Controller1.Screen.print(\"        \");\n    } \n    else {\n    Controller1.Screen.print(\"L: \");\n    Controller1.Screen.print(drive_leftFront.position(turns) - pastLeft);\n    Controller1.Screen.print(\" R: \");\n    Controller1.Screen.print(drive_rightFront.position(turns) - pastRight);\n    }\n    Controller1.Screen.newLine();\n    wait(0.3,seconds);\n\n    if (Controller1.ButtonUp.pressing()) {\n      pastRight = drive_rightFront.position(turns);\n      pastLeft = drive_leftFront.position(turns);\n    }\n  }\n}\n\nvoid turnToDegree(int destination, int pivotSetting, float timeout) {\n  driveMacro(SetSpeed, 0, 0);\n  float error, seam, noseam, currentHeading, leftTurn, rightTurn, timeMax, pastError;\n  int dir;\n  leftTurn = 1;\n  rightTurn = 1;\n  timeMax = Brain.Timer.time(seconds) + timeout;\n  pastError = 0;\n  if (pivotSetting != Both) {\n    if (pivotSetting == Left) {\n      leftTurn = 2.5;\n      rightTurn = 0;\n    } \n    else if (pivotSetting == Right) {\n      leftTurn = 0;\n      rightTurn = 2.5;\n    }\n  }\n  do {\n    currentHeading = drive_gyro.heading(degrees);\n    noseam = (::fabs(destination - currentHeading)) * -1;\n    seam = 360 - std::max((float) destination, currentHeading) + std::min( (float) destination, currentHeading);\n    dir = (currentHeading - destination) / (::fabs(currentHeading - destination));\n    if (seam < ::fabs(noseam)) {\n      error = seam * dir;\n    }\n    else {\n      error = noseam * dir;\n    }\n    dir = error / ::fabs(error);\n\n    driveMacro(SetSpeed, ((error * turnP) + (turnConst + ((error - pastError) * turnD)) * dir ) * leftTurn, ((error * turnP) + (turnConst + ((error - pastError) * turnD)) * dir ) * -1 * rightTurn);\n    driveMacro(Spin);\n    printf(\"current: %f, error: %f\\n\", currentHeading, error);\n    pastError = error;\n  } while (::fabs(error) > 1 && Brain.Timer.time(seconds) < timeMax);\n  Brain.Screen.print(\"finsih \");\n  Brain.Screen.print(currentHeading);\n  Brain.Screen.newLine();\n  driveMacro(SetSpeed, 100, 100);\n}\n\nvoid moveForTurns(float destination, int timeout) {\n  driveMacro(SetBraking, Coast);\n  int timeMax = Brain.Timer.time(seconds) + timeout;\n  float endGoal = drive_leftFront.position(turns) + destination;\n  float error = 0;\n  int dir;\n  do {\n    error = endGoal - drive_leftFront.position(turns);\n    dir = error / ::fabs(error);\n    driveMacro(SetSpeed, (error * moveP) + (moveConst * dir), (error * moveP) + (moveConst * dir));\n    driveMacro(Spin);\n  } while (::fabs(error) > 0.1 && Brain.Timer.time(seconds) < timeMax);\n  driveMacro(SetBraking, Hold);\n  driveMacro(SetSpeed, 100, 100);\n}\n\nvoid cavemanMove(int speedLeft, int speedRight, int mode, int argument1, int argument2) {\n  driveMacro(SetSpeed, speedLeft, speedRight);\n  if (mode == Time){\n    wait(argument1, seconds);\n  } else {\n    int old_left = drive_leftFront.position(turns);\n    int old_right = drive_rightFront.position(turns);\n    while (drive_leftFront.position(turns) < (old_left + argument1) || drive_rightFront.position(turns) < (old_right + argument2)) { \n\n    }\n  }\n} \n\nvoid driveMacro(int action, float argument1, float argument2) {  \n  if (action == Spin) {\n    drive_leftFront.spin(forward);\n    drive_leftMid.spin(forward);\n    drive_leftBack.spin(forward);\n    drive_rightFront.spin(forward);\n    drive_rightMid.spin(forward);\n    drive_rightBack.spin(forward);\n  } \n  else if (action == Stop){\n    drive_leftFront.stop();\n    drive_leftMid.stop();\n    drive_leftBack.stop();\n    drive_rightFront.stop();\n    drive_rightMid.stop();\n    drive_rightBack.stop();\n  }\n  else if (action == SetSpeed) {\n    drive_leftFront.setVelocity(argument1, percent);\n    drive_leftMid.setVelocity(argument1, percent);\n    drive_leftBack.setVelocity(argument1, percent);\n    drive_rightFront.setVelocity(argument2, percent);\n    drive_rightMid.setVelocity(argument2, percent);\n    drive_rightBack.setVelocity(argument2, percent);\n  }\n  else if (action == SpinFor) {\n    drive_leftFront.spinFor(forward, argument1, turns, false);\n    drive_leftMid.spinFor(forward, argument1, turns, false);\n    drive_leftBack.spinFor(forward, argument1, turns, false);\n    drive_rightFront.spinFor(forward, argument2, turns, false);\n    drive_rightMid.spinFor(forward, argument2, turns, false);\n    drive_rightBack.spinFor(forward, argument2, turns, true);\n    driveMacro(Stop);\n  } \n  else if (action == SetBraking) {\n    if (argument1 == Brake) {\n    drive_leftFront.setStopping(brake);\n    drive_leftMid.setStopping(brake);\n    drive_leftBack.setStopping(brake);\n    drive_rightFront.setStopping(brake);\n    drive_rightMid.setStopping(brake);\n    drive_rightBack.setStopping(brake);\n    }\n    else if (argument1 == Coast) {\n    drive_leftFront.setStopping(coast);\n    drive_leftMid.setStopping(coast);\n    drive_leftBack.setStopping(coast);\n    drive_rightFront.setStopping(coast);\n    drive_rightMid.setStopping(coast);\n    drive_rightBack.setStopping(coast);\n    }\n    else if (argument1 == Hold) {\n    drive_leftFront.setStopping(hold);\n    drive_leftMid.setStopping(hold);\n    drive_leftBack.setStopping(hold);\n    drive_rightFront.setStopping(hold);\n    drive_rightMid.setStopping(hold);\n    drive_rightBack.setStopping(hold);\n    }\n  }\n  else if (action == SetTimeout) {\n    drive_leftFront.setTimeout(argument1, seconds);\n    drive_leftMid.setTimeout(argument1, seconds);\n    drive_leftBack.setTimeout(argument1, seconds);\n    drive_rightFront.setTimeout(argument1, seconds);\n    drive_rightMid.setTimeout(argument1, seconds);\n    drive_rightBack.setTimeout(argument1, seconds);\n  }\n  else if (action == SpinTo) {\n    drive_leftFront.spinToPosition(argument1, turns);\n    drive_leftMid.spinToPosition(argument1, turns);\n    drive_leftBack.spinToPosition(argument1, turns);\n    drive_rightFront.spinToPosition(argument2, turns);\n    drive_rightMid.spinToPosition(argument2, turns);\n    drive_rightBack.spinToPosition(argument2, turns);\n  }\n}\n\n//autons\nvoid auton_Matchload_AWP() {\n  // matchload side\n  // quick one to cook(AWP)\n  moveForTurns(0.1);\n  wings.set(1);\n  turnToDegree(285);\n  wings.set(0);\n  turnToDegree(290);\n  moveForTurns(-2.3);\n  driveMacro(SetSpeed, 0, 0);\n  driveMacro(Spin, 0);\n  \n  Brain.Screen.print(\"code ended \");\n}\n\nvoid auton_goalSide() {\n  intake_motor.setStopping(coast);\n\n  //while (!Controller1.ButtonA.pressing()) { }\n  //get ball\n  intake_motor.setVelocity(100,percent);\n  intake_motor.spin(forward);\n  wait(0.4,seconds);\n  intake_motor.stop();\n\n  //flick out triball\n  moveForTurns(-1.63);\n  turnToDegree(330);\n  wings.set(true);\n  moveForTurns(-1.3);\n  wings.set(false);\n  /*\n  driveMacro(SetSpeed, -100, 100);\n  driveMacro(Spin);\n  while (drive_gyro.heading(degrees) > 320) { }\n  driveMacro(SetSpeed, 0, 0);\n  driveMacro(Stop);\n  wings.set(false);\n  wait(0.5,seconds); //DONT TOUCH THIS PLEASE WIENFowenfw\n  */\n\n  //shove\n  turnToDegree(302);\n  driveMacro(SetSpeed, -100, -100);\n  driveMacro(Spin);\n  wait(0.6, seconds); \n  //backwards\n  moveForTurns(0.55);\n  turnToDegree(100);\n  driveMacro(Stop);\n  intake_motor.spin(reverse);\n  wait(0.8,seconds);\n  driveMacro(SetSpeed, 100, 100);\n  driveMacro(Spin);\n  wait(0.6, seconds); \n  intake_motor.stop();\n\n  //align to matchload bar\n  driveMacro(SetSpeed, -100, -70);\n  driveMacro(Spin);\n  wait(0.8,seconds);\n\n  //get 4th ball\n  turnToDegree(30);\n  intake_motor.spin(forward);\n  moveForTurns(2.8);\n  driveMacro(Stop);\n  wait(0.2,seconds);\n\n  //shoot out 4th ball\n  moveForTurns(-0.1);\n  intake_motor.stop();\n  turnToDegree(150);\n  moveForTurns(1);\n  driveMacro(Stop);\n  intake_motor.spin(reverse);\n  wait(0.6,seconds);\n\n  // Go for double triball stack\n  turnToDegree(39);\n  intake_motor.spin(forward);\n  moveForTurns(1.3);\n  driveMacro(Stop);\n  wait(0.3,seconds);\n  intake_motor.stop();\n\n  //shove\n  turnToDegree(0);\n  wings.set(true);\n  driveMacro(SetSpeed, -100, -100);\n  driveMacro(Spin);\n  wait(1,seconds);\n  //final shove\n  wings.set(false);\n  moveForTurns(0.5);\n  turnToDegree(180);\n  intake_motor.spin(reverse);\n  wait(0.5,seconds);\n  driveMacro(SetSpeed, 100, 100);\n  driveMacro(Spin);\n  wait(0.7, seconds);\n  driveMacro(SetSpeed, 0, 0);\n  driveMacro(Spin);\n\n  \n\n\n  driveMacro(Stop);\n  intake_motor.stop();\n  Brain.Screen.print(\"code ended \");\n  autonHelper();\n}\n\nvoid auton_skills(){\n  //front section\n  moveForTurns(-1.4);\n  turnToDegree(0, Right);\n  driveMacro(SetSpeed, -100, -100); driveMacro(Spin);\n  wait(0.75, seconds);\n  driveMacro(Stop);\n  moveForTurns(0.70);\n  //This turn says what angle the cata shoots at\n  turnToDegree(75, Both, 3);\n  driveMacro(Stop);\n\n  outtake_motor.setVelocity(cataSpeed, percent);\n  outtake_motor.spin(forward);\n  wait(30, seconds);\n  while(cata_rotation.angle() < manualTurnBackAngle){\n      outtake_motor.spin(forward);\n    }\n  \n  outtake_motor.stop();\n  //while (!Controller1.ButtonUp.pressing()) { }\n\n  //traveling along the edge\n  turnToDegree(135, Right); \n  moveForTurns(-1.4); //if it bumps and gets stuck on the bar change this by 0.1 incremets\n  turnToDegree(87); //or this one agin by small oncrements\n  moveForTurns(-4);\n  //driveMacro(Stop);\n  //while (!Controller1.ButtonUp.pressing()) { }\n\n  //shoving into the goal\n  turnToDegree(80);\n  driveMacro(SetSpeed, -90, -37);\n  driveMacro(Spin);\n  wait(0.5,seconds);\n  driveMacro(SetSpeed, -100, -100);\n  driveMacro(Spin);\n  wait(1.5,seconds);\n  moveForTurns(0.65);\n  turnToDegree(30);\n  driveMacro(SetSpeed, -100, -100);\n  driveMacro(Spin);\n  wait(1,seconds);\n\n  //alighing to boatdrive bar\n  moveForTurns(0.4);\n  turnToDegree(90);\n  driveMacro(Stop);\n  //while (!Controller1.ButtonUp.pressing()) { }\n  driveMacro(SetSpeed, 60, 60); driveMacro(Spin); \n  wait(1, seconds); \n  driveMacro(SetSpeed, 20, 20); driveMacro(Spin); \n  wait(0.7, seconds); \n  /*moveForTurns(1.3);\n  turnToDegree(180, Left);\n  moveForTurns(0.6);\n  turnToDegree(63);\n  driveMacro(SetSpeed, 70, 70); driveMacro(Spin); \n  wait(0.7, seconds);\n  driveMacro(SetSpeed, 20, 20); driveMacro(Spin); \n  wait(0.3, seconds); */\n\n  \n  \n  //push 1st angle\n  turnToDegree(57);\n  driveMacro(SetSpeed, -75, -100); driveMacro(Spin); \n  wait(2, seconds); \n  moveForTurns(1);\n  driveMacro(SetSpeed, -100, -100); driveMacro(Spin); \n  wait(1, seconds);\n\n  //push 2nd angle\n  //driveMacro(Stop);\n  //while (!Controller1.ButtonUp.pressing()) { }\n  moveForTurns(1.60, 2);\n  turnToDegree(179);\n  moveForTurns(1.4);\n  turnToDegree(135, Right);\n  wings.set(true);\n  driveMacro(SetSpeed, -100, -60); driveMacro(Spin); \n  wait(2.5, seconds);\n  moveForTurns(1);\n  driveMacro(SetSpeed, -100, -100); driveMacro(Spin); \n  wait(1, seconds);\n  wings.set(false);\n\n  moveForTurns(1);\n  driveMacro(SetSpeed, -100, 100); driveMacro(Spin); \n  wait(2.5, seconds);\n  driveMacro(Stop);\n  Brain.Screen.print(\"code ended \");\n}\n\nvoid auton_init(){\n  drive_gyro.calibrate();\n  wait(3,seconds);\n  Brain.Screen.print(\"finished callabrating \");\n  Brain.Screen.newLine();\n\n  driveMacro(SetBraking, Hold);\n  driveMacro(SetTimeout, 30);\n  driveMacro(SetSpeed, 100, 100);\n  intake_motor.setVelocity(100, percent);\n  outtake_motor.setVelocity(100, percent);\n}\n\n\n\n\n\n\n\n\n\n\n\n/*\ndrive_leftFront\ndrive_leftMid\ndrive_leftBack\ndrive_rightFront\ndrive_rightMid\ndrive_rightBack\n*/\n\n\nfloat map(float lowerA, float upperA, float lowerB, float upperB, float input){\n  float inValNorm = input - lowerA;\n  float aUpperNorm = upperA - lowerA;\n  float normPosition = inValNorm / aUpperNorm;\n\n  float bUpperNorm = upperB - lowerB;\n  float bValNorm = normPosition * bUpperNorm;\n  float outVal = lowerB + bValNorm;\n\n  return outVal;\n}","textLanguage":"cpp","robotConfig":[],"slot":2,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.5","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}