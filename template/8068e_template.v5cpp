{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nrotation Rotation2 = rotation(PORT2, false);\n\ndigital_out DigitalOutA = digital_out(Brain.ThreeWirePort.A);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n/*\ntodo list\n1. \n2. \n3. \n*/\n \n\n// Include Libarys\n#include \"vex.h\"\n#include \"algorithm\"\n#include \"utility\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\ncompetition Competition = competition();                                 \n\n\n// keyword Declreation \n#define Spin 0\n#define Stop 1\n#define SetSpeed 2\n#define SpinFor 3\n#define SetBraking 4\n#define SetTimeout 5\n#define SpinTo 6\n\n#define Brake 0\n#define Coast 1\n#define Hold 2\n\n#define Left 0\n#define Right 1\n#define Both 2\n\n#define Match 0\n#define Skills 1\n\n// Function and variable teasers\n  void autonHelper();\n\n  void driveMacro(int action, float argument1 = 100000, float argument2 = 100000);\n  void turnToDegree(int destination, int pivotSetting = Both, float timeout = 100000);\n  void moveForTurns(float destination, int timeout = 100000);\n\n  void driver_Control();\n  void auton_one();\n  void auton_two();\n  void auton_skills();\n  void auton_init();\n\n// Ports decleration\n  // drivetrain \n  //TODO[1] --> edit the ports, gear ratio, and rotation of your drivetrain motors\n  controller Controller1 = controller(primary);\n  motor drive_leftFront = motor(PORT14, ratio18_1, true);\n  motor drive_leftMid = motor(PORT15, ratio18_1, false);\n  motor drive_leftBack = motor(PORT16, ratio18_1, true);\n  motor drive_rightFront = motor(PORT11, ratio18_1, false);\n  motor drive_rightMid = motor(PORT12, ratio18_1, true);\n  motor drive_rightBack = motor(PORT13, ratio18_1, false);\n  inertial drive_gyro = inertial(PORT19); // TODO[2] --> edit the port of your gyro sensor\n\n  //Periphrals\n  //TODO[3] --> define the other stuff your using eg.\n  // motor intake_motor = motor(PORT1, ratio18_1, false); // for a motor\n  // rotation Rotation2 = rotation(PORT2, false); // for a v5 rotation sensor\n  // digital_out hang_piston = digital_out(Brain.ThreeWirePort.A); // for a solonoid at port A\n  // digital_in intake_limitSwitch = digital_out(Brain.ThreeWirePort.b); // for a limit switch at port B\n  // see https://api.vex.com/v5/home/cpp/\n\n  //variables\n  int mode = Match; // TODO[4] --> choose whether you are running a 'Match' or a 'Skills' run before uploading\n\n  //TODO[5] --> these are the pid variables for turnToDegree() and moveForTurns(). you have to tune them like you tune\n  //a line tracking bot. the values below were from 8068e worlds bot\n  float turnP = 0.57;\n  float turnConst = 2;\n  float turnD = 0;\n  float moveP = 80;\n  float moveConst = 17;\n\n  \nvoid pre_auton(void){\n  auton_init();\n}\n\nint main() {\n  //TODO[6] --> uncomment the code that you want to run before uploading\n  //--COMPETITION TEMPLATE--//\n  //Competition.drivercontrol(driver_Control);\n\n  //For auton_one:\n  //Competition.autonomous(auton_one);\n\n  // For auton_two\n  //Competition.autonomous(auton_two);\n\n  //For Auton Skills:\n  //Competition.autonomous(auton_skills);\n\n  pre_auton();\n  //--COMPETITION TEMPLATE--//\n\n\n\n  //--TESTING--//\n  //driver_Control();\n  //auton_one();\n  //auton_two();\n  //auton_skills();\n  //autonHelper();\n}\n\n\n\n\n\n\n\n// fuunctions\nvoid driver_Control() {\n  driveMacro(SetBraking, Coast); // TODO[7] --> choose Brake, Coast or Hold for your drive train during driver control\n  int fwd, sideways, leftTrain, rightTrain;\n\n  //initalises controller vibration\n  int timeLast = Brain.Timer.time(seconds);\n  int matchLength = 105; \n  if (mode == Skills) {\n    matchLength = 60;\n  }\n  int last_rumble = matchLength;\n\n  while (true) {\n    // drivetrain control\n    fwd = Controller1.Axis3.position();\n    sideways = Controller1.Axis1.position();\n    leftTrain = fwd + sideways;\n    rightTrain = fwd - sideways;\n    driveMacro(SetSpeed, leftTrain, rightTrain);\n    driveMacro(Spin);\n\n    //TODO[8] --> code stuff other than the drivetrain for your driver control mode\n    //github has the over under code for you to refer to\n    \n\n\n\n\n    //rumble for timer --> will vibrate the controller in the last 30, 15 and 10 seconds of the match\n    // if you dont want, you can delete or edit the rumble timings\n    if (Brain.Timer.time(seconds) - timeLast > matchLength - 30 && last_rumble > 30) {\n      Controller1.rumble(\"-\");\n      last_rumble = 30;\n    } else if (Brain.Timer.time(seconds) - timeLast > matchLength - 15 && last_rumble > 16) {\n      Controller1.rumble(\"--\");\n      last_rumble = 15;\n    } else if (Brain.Timer.time(seconds) - timeLast > matchLength - 10 && last_rumble > 11) {\n      Controller1.rumble(\"---\");\n      last_rumble = 10;\n    }\n    wait(0.005, seconds);\n  }\n}\n\n\n//autons\nvoid auton_one() {\n  //TODO[9] --> your auton_one code\n\n\n  driveMacro(Stop);\n  Brain.Screen.print(\"code ended \");\n}\n\nvoid auton_two() {\n  //TODO[9] --> your auton_two code\n\n\n  driveMacro(Stop);\n  Brain.Screen.print(\"code ended \");\n}\n\nvoid auton_skills(){\n  //TODO[9] --> your skills code\n\n  driveMacro(Stop);\n  Brain.Screen.print(\"code ended \");\n}\n\nvoid auton_init(){\n  //TODO[10] --> do wtv you want to set up before each auton\n  //this function is called the moment the brain powers up, even before the match starts, in the pre_auton() funciton\n  //below is some suggestions\n  drive_gyro.calibrate();\n  driveMacro(SetBraking, Hold); //recomendded to set to hold during auton\n  driveMacro(SetTimeout, 30);\n  driveMacro(SetSpeed, 100, 100);\n  Brain.Screen.print(\"ready to run \");\n  Brain.Screen.newLine();\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//helping functions, see documentation\nvoid autonHelper() {\n  driveMacro(SetBraking, Coast);\n  float pastLeft = 0;\n  float pastRight = 0;\n  while (1) {\n    if (Controller1.ButtonRight.pressing()) {\n      Controller1.Screen.print(\"gyro: \");\n      Controller1.Screen.print(drive_gyro.heading(degrees));\n      Controller1.Screen.print(\"               \");\n    } \n    else {\n    Controller1.Screen.print(\"L: \");\n    Controller1.Screen.print(drive_leftFront.position(turns) - pastLeft);\n    Controller1.Screen.print(\" R: \");\n    Controller1.Screen.print(drive_rightFront.position(turns) - pastRight);\n    Controller1.Screen.print(\"               \");\n    }\n    Controller1.Screen.newLine();\n    wait(0.3,seconds);\n\n    if (Controller1.ButtonUp.pressing()) {\n      pastRight = drive_rightFront.position(turns);\n      pastLeft = drive_leftFront.position(turns);\n    }\n  }\n}\n\nvoid turnToDegree(int destination, int pivotSetting, float timeout) {\n  driveMacro(SetSpeed, 0, 0);\n  float error, seam, noseam, currentHeading, leftTurn, rightTurn, timeMax, pastError;\n  int dir;\n  leftTurn = 1;\n  rightTurn = 1;\n  timeMax = Brain.Timer.time(seconds) + timeout;\n  pastError = 0;\n  if (pivotSetting != Both) {\n    if (pivotSetting == Left) {\n      leftTurn = 2.5;\n      rightTurn = 0;\n    } \n    else if (pivotSetting == Right) {\n      leftTurn = 0;\n      rightTurn = 2.5;\n    }\n  }\n  do {\n    currentHeading = drive_gyro.heading(degrees);\n    noseam = (::fabs(destination - currentHeading)) * -1;\n    seam = 360 - std::max((float) destination, currentHeading) + std::min( (float) destination, currentHeading);\n    dir = (currentHeading - destination) / (::fabs(currentHeading - destination));\n    if (seam < ::fabs(noseam)) {\n      error = seam * dir;\n    }\n    else {\n      error = noseam * dir;\n    }\n    dir = error / ::fabs(error);\n\n    driveMacro(SetSpeed, ((error * turnP) + (turnConst + ((error - pastError) * turnD)) * dir ) * leftTurn, ((error * turnP) + (turnConst + ((error - pastError) * turnD)) * dir ) * -1 * rightTurn);\n    driveMacro(Spin);\n    printf(\"current: %f, error: %f\\n\", currentHeading, error);\n    pastError = error;\n  } while (::fabs(error) > 1 && Brain.Timer.time(seconds) < timeMax);\n  Brain.Screen.print(\"finsih \");\n  Brain.Screen.print(currentHeading);\n  Brain.Screen.newLine();\n  driveMacro(SetSpeed, 100, 100);\n}\n\nvoid moveForTurns(float destination, int timeout) {\n  driveMacro(SetBraking, Coast);\n  int timeMax = Brain.Timer.time(seconds) + timeout;\n  float endGoal = drive_leftFront.position(turns) + destination;\n  float error = 0;\n  int dir;\n  do {\n    error = endGoal - drive_leftFront.position(turns);\n    dir = error / ::fabs(error);\n    driveMacro(SetSpeed, (error * moveP) + (moveConst * dir), (error * moveP) + (moveConst * dir));\n    driveMacro(Spin);\n  } while (::fabs(error) > 0.1 && Brain.Timer.time(seconds) < timeMax);\n  driveMacro(SetBraking, Hold);\n  driveMacro(SetSpeed, 100, 100);\n}\n\nvoid driveMacro(int action, float argument1, float argument2) {  \n  if (action == Spin) {\n    drive_leftFront.spin(forward);\n    drive_leftMid.spin(forward);\n    drive_leftBack.spin(forward);\n    drive_rightFront.spin(forward);\n    drive_rightMid.spin(forward);\n    drive_rightBack.spin(forward);\n  } \n  else if (action == Stop){\n    drive_leftFront.stop();\n    drive_leftMid.stop();\n    drive_leftBack.stop();\n    drive_rightFront.stop();\n    drive_rightMid.stop();\n    drive_rightBack.stop();\n  }\n  else if (action == SetSpeed) {\n    drive_leftFront.setVelocity(argument1, percent);\n    drive_leftMid.setVelocity(argument1, percent);\n    drive_leftBack.setVelocity(argument1, percent);\n    drive_rightFront.setVelocity(argument2, percent);\n    drive_rightMid.setVelocity(argument2, percent);\n    drive_rightBack.setVelocity(argument2, percent);\n  }\n  else if (action == SpinFor) {\n    drive_leftFront.spinFor(forward, argument1, turns, false);\n    drive_leftMid.spinFor(forward, argument1, turns, false);\n    drive_leftBack.spinFor(forward, argument1, turns, false);\n    drive_rightFront.spinFor(forward, argument2, turns, false);\n    drive_rightMid.spinFor(forward, argument2, turns, false);\n    drive_rightBack.spinFor(forward, argument2, turns, true);\n    driveMacro(Stop);\n  } \n  else if (action == SetBraking) {\n    if (argument1 == Brake) {\n    drive_leftFront.setStopping(brake);\n    drive_leftMid.setStopping(brake);\n    drive_leftBack.setStopping(brake);\n    drive_rightFront.setStopping(brake);\n    drive_rightMid.setStopping(brake);\n    drive_rightBack.setStopping(brake);\n    }\n    else if (argument1 == Coast) {\n    drive_leftFront.setStopping(coast);\n    drive_leftMid.setStopping(coast);\n    drive_leftBack.setStopping(coast);\n    drive_rightFront.setStopping(coast);\n    drive_rightMid.setStopping(coast);\n    drive_rightBack.setStopping(coast);\n    }\n    else if (argument1 == Hold) {\n    drive_leftFront.setStopping(hold);\n    drive_leftMid.setStopping(hold);\n    drive_leftBack.setStopping(hold);\n    drive_rightFront.setStopping(hold);\n    drive_rightMid.setStopping(hold);\n    drive_rightBack.setStopping(hold);\n    }\n  }\n  else if (action == SetTimeout) {\n    drive_leftFront.setTimeout(argument1, seconds);\n    drive_leftMid.setTimeout(argument1, seconds);\n    drive_leftBack.setTimeout(argument1, seconds);\n    drive_rightFront.setTimeout(argument1, seconds);\n    drive_rightMid.setTimeout(argument1, seconds);\n    drive_rightBack.setTimeout(argument1, seconds);\n  }\n  else if (action == SpinTo) {\n    drive_leftFront.spinToPosition(argument1, turns);\n    drive_leftMid.spinToPosition(argument1, turns);\n    drive_leftBack.spinToPosition(argument1, turns);\n    drive_rightFront.spinToPosition(argument2, turns);\n    drive_rightMid.spinToPosition(argument2, turns);\n    drive_rightBack.spinToPosition(argument2, turns);\n  }\n}\n","textLanguage":"cpp","robotConfig":[{"port":[2],"name":"Rotation2","customName":false,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false"}},{"port":[1],"name":"DigitalOutA","customName":false,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22}],"slot":2,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.5","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}